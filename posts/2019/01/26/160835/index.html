<!doctype html><html lang=ja><head><meta charset=utf-8><meta http-equiv=content-type content="text/html"><meta name=viewport content="width=device-width,initial-scale=1"><title itemprop=name>メタプログラミングRuby ５章　クラス定義 | QWYNG.dev</title>
<meta property="og:title" content="メタプログラミングRuby ５章　クラス定義 | QWYNG.dev"><meta name=twitter:title content="メタプログラミングRuby ５章　クラス定義 | QWYNG.dev"><meta itemprop=name content="メタプログラミングRuby ５章　クラス定義 | QWYNG.dev"><meta name=application-name content="メタプログラミングRuby ５章　クラス定義 | QWYNG.dev"><meta property="og:site_name" content><meta name=description content><meta itemprop=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:locale" content="ja"><meta name=language content="ja"><link rel=alternate hreflang=en href=https://qwyng.dev/posts/2019/01/26/160835/ title><meta property="og:type" content="article"><meta property="og:article:published_time" content=2019-01-26T16:08:00+0900><meta property="article:published_time" content=2019-01-26T16:08:00+0900><meta property="og:url" content="https://qwyng.dev/posts/2019/01/26/160835/"><script defer type=application/ld+json>{"@context":"http://schema.org","@type":"Article","headline":"メタプログラミングRuby ５章　クラス定義","author":{"@type":"Person","name":""},"datePublished":"2019-01-26","description":"","wordCount":3921,"mainEntityOfPage":"True","dateModified":"2019-01-26","image":{"@type":"imageObject","url":""},"publisher":{"@type":"Organization","name":"QWYNG.dev"}}</script><meta name=generator content="Hugo 0.134.0"><meta property="og:description" content="

    
特異メソッド
            カレントクラス
            クラスインスタンス変数
            特異メソッド
            クラスマクロ
        
    
    
特異クラス
            大統一理論
            Object#extend
        
    
    
メソッドラッパー
            アラウンドエイリアス
            Refinements
            Prependラッパー
        
    
    ５章のクイズ
    まとめ

特異メソッド
カレントクラス
Rubyのプログラムは常にカレントオブジェクトselfを持っているが、同時にカレントクラスも持っています。"><meta property="og:type" content="website"><meta property="og:title" content="メタプログラミングRuby ５章　クラス定義 - QWYNG.dev"><meta property="og:url" content="https://qwyng.dev/posts/2019/01/26/160835/"><meta name=og:image content="https://qwyng.dev/"><meta name=twitter:card content="summary"><link rel=canonical href=https://qwyng.dev/posts/2019/01/26/160835/><link href=/style.min.e390ba7da26222f4dc42a349955d76dbbe44e5ce2535a43de5a70633a0a9ec3c.css rel=stylesheet><link href=/code-highlight.min.706d31975fec544a864cb7f0d847a73ea55ca1df91bf495fd12a177138d807cf.css rel=stylesheet><link rel=apple-touch-icon sizes=180x180 href=/icons/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/icons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/icons/favicon-16x16.png><link rel=mask-icon href=/icons/safari-pinned-tab.svg><link rel="shortcut icon" href=/favicon.ico><link rel=manifest href=https://qwyng.dev/site.webmanifest><meta name=msapplication-config content="/browserconfig.xml"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#434648"><link rel=icon type=image/svg+xml href=/icons/favicon.svg><script async src="https://www.googletagmanager.com/gtag/js?id=G-9JVVYL7X5D"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9JVVYL7X5D")}</script></head><body data-theme class=notransition><script src=/js/theme.min.8961c317c5b88b953fe27525839672c9343f1058ab044696ca225656c8ba2ab0.js integrity="sha256-iWHDF8W4i5U/4nUlg5ZyyTQ/EFirBEaWyiJWVsi6KrA="></script><div class=navbar role=navigation><nav class=menu aria-label="Main Navigation"><a href=https://qwyng.dev/ class=logo><svg width="25" height="25" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-home"><title/><path d="M3 9l9-7 9 7v11a2 2 0 01-2 2H5a2 2 0 01-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>
</a><input type=checkbox id=menu-trigger class=menu-trigger>
<label for=menu-trigger><span class=menu-icon><svg width="25" height="25" stroke="currentcolor" fill="none" viewBox="0 0 14 14"><title>Menu</title><path stroke-linecap="round" stroke-linejoin="round" d="M10.595 7H3.40726"/><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 3.51488H3.49301"/><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 10.4851H3.49301"/><path stroke-linecap="round" stroke-linejoin="round" d="M.5 12.5V1.5c0-.552285.447715-1 1-1h11C13.0523.5 13.5.947715 13.5 1.5v11C13.5 13.0523 13.0523 13.5 12.5 13.5H1.5C.947715 13.5.5 13.0523.5 12.5z"/></svg></span></label><div class=trigger><ul class=trigger-container><li><a class=menu-link href=/about/>About</a></li><li><a class=menu-link href=/posts/>記事一覧</a></li><li><a class=menu-link href=/index.xml>RSS</a></li><li class=menu-separator><span>|</span></li></ul><a id=mode href=#><svg class="mode-sunny" width="21" height="21" viewBox="0 0 14 14" stroke-width="1"><title>LIGHT</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1=".5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1=".5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/></g></svg><svg class="mode-moon" width="21" height="21" viewBox="0 0 14 14" stroke-width="1"><title>DARK</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1=".5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1=".5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/></g></svg></a></div></nav></div><div class="wrapper post"><main class=page-content aria-label=Content><article><header class=header><h1 class=header-title>メタプログラミングRuby ５章　クラス定義</h1><div class=post-meta><time datetime=2019-01-26T16:08:00+09:00 itemprop=datePublished>Jan 26, 2019</time></div></header><div class=page-content><body><ul class=table-of-contents><li><a href=#%E7%89%B9%E7%95%B0%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89>特異メソッド</a><ul><li><a href=#%E3%82%AB%E3%83%AC%E3%83%B3%E3%83%88%E3%82%AF%E3%83%A9%E3%82%B9>カレントクラス</a></li><li><a href=#%E3%82%AF%E3%83%A9%E3%82%B9%E3%82%A4%E3%83%B3%E3%82%B9%E3%82%BF%E3%83%B3%E3%82%B9%E5%A4%89%E6%95%B0>クラスインスタンス変数</a></li><li><a href=#%E7%89%B9%E7%95%B0%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89-1>特異メソッド</a></li><li><a href=#%E3%82%AF%E3%83%A9%E3%82%B9%E3%83%9E%E3%82%AF%E3%83%AD>クラスマクロ</a></li></ul></li><li><a href=#%E7%89%B9%E7%95%B0%E3%82%AF%E3%83%A9%E3%82%B9>特異クラス</a><ul><li><a href=#%E5%A4%A7%E7%B5%B1%E4%B8%80%E7%90%86%E8%AB%96>大統一理論</a></li><li><a href=#Objectextend>Object#extend</a></li></ul></li><li><a href=#%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%83%A9%E3%83%83%E3%83%91%E3%83%BC>メソッドラッパー</a><ul><li><a href=#%E3%82%A2%E3%83%A9%E3%82%A6%E3%83%B3%E3%83%89%E3%82%A8%E3%82%A4%E3%83%AA%E3%82%A2%E3%82%B9>アラウンドエイリアス</a></li><li><a href=#Refinements>Refinements</a></li><li><a href=#Prepend%E3%83%A9%E3%83%83%E3%83%91%E3%83%BC>Prependラッパー</a></li></ul></li><li><a href=#%EF%BC%95%E7%AB%A0%E3%81%AE%E3%82%AF%E3%82%A4%E3%82%BA>５章のクイズ</a></li><li><a href=#%E3%81%BE%E3%81%A8%E3%82%81>まとめ</a></li></ul><h2 id=特異メソッド>特異メソッド</h2><h3 id=カレントクラス>カレントクラス</h3><p><a class=keyword href=http://d.hatena.ne.jp/keyword/Ruby>Ruby</a>のプログラムは常にカレントオブジェクトselfを持っているが、同時にカレントクラスも持っています。</p><pre class="code lang-ruby" data-lang=ruby data-unlink> class C
  def m1
    p self
    def m2; end
  end
end

class D &lt; C; end

obj = D.new
obj.m1 # =&gt; &lt;D:0x00007fc1e2865938&gt;

p C.instance_methods(false) # =&gt;[:m1, :m2]
p D.instance_methods(false) # =&gt; []
 </pre><p><a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%E1%A5%BF%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0>メタプログラミング</a><a class=keyword href=http://d.hatena.ne.jp/keyword/Ruby>Ruby</a>のサンプルに少し書き足してみました。
カレントオブジェクトはDクラスの<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9>インスタンス</a>ですが、カレントクラスはCクラスであることがわかりますね。よってm2はCクラスの<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9>インスタンス</a>メソッドになっています。</p><p>Classでクラスを開くことでカレントクラスを変えることができるのですが、この方法はカレントクラスにしたいクラスの名前がわからないと使えません。クラス名がわからない時に使うのが class_evalメソッドです。</p><pre class="code lang-ruby" data-lang=ruby data-unlink> def add_method_to(a_class)
  a_class.class_eval do
    def m
      'Hello!'
    end
  end
end

add_method_to(String)
p "string".m # =&gt; 'Hello!'
 </pre><p>このadd_method_toメソッドではクラスを引数にとってclass_evalを使うことで引数にとったクラスにカレントクラスを変更してからメソッドを定義しています。
class_evalは第四章のinstance_evalとは別物です。
instance_evalはselfを変更してブロック内を評価してくれるものでしたが、class_evalはselfに加えてカレントクラスも変更します。
スコープゲートを開いているわけではないのでスコープは変わりません。</p><h3 id=クラスインスタンス変数>クラス<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9>インスタンス</a>変数</h3><p>クラスの<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9>インスタンス</a>変数とクラスのオブジェクトの<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9>インスタンス</a>変数は別物です。</p><pre class="code lang-ruby" data-lang=ruby data-unlink> class Myclass
  @my_var = 1

  def self.read
    @my_var
  end

  def write
    @my_var = 2
  end

  def read
    @my_var
  end
end

obj = Myclass.new
p obj.read # =&gt; nil
obj.write
p obj.read # =&gt; 2
p Myclass.read # =&gt; 1
 </pre><p>ここでは2つの異なるオブジェクトである@my_varを定義しています。
クラスもオブジェクトの一つであるということを念頭において考えて行くのが大事になってきます。
最初にでてくる@my_varがクラス<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9>インスタンス</a>変数。2つ目@my_varが今回だとobjオブジェクトの<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9>インスタンス</a>変数ですね。
（ここ<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%E1%A5%BF%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0>メタプログラミング</a><a class=keyword href=http://d.hatena.ne.jp/keyword/Ruby>Ruby</a>では1つ目の@my_varがobjの<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9>インスタンス</a>変数で2つ目の@my_varがMyclassのクラス<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9>インスタンス</a>変数だ、と書かれているのですが、コードの順番で行くと逆なので少しわかりにくかったです。説明の順番としては仕方ないのかもしれないですが。）
クラス<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9>インスタンス</a>変数はClassクラスに属しているオブジェクトの<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9>インスタンス</a>変数というのが正しいです。MyclassはClassクラスの<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9>インスタンス</a>なのでその中で定義されたものはクラス<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9>インスタンス</a>変数となります。
クラス<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9>インスタンス</a>変数はクラスしかアクセスできず、そのクラスの<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9>インスタンス</a>からアクセスすることはできません。</p><h3 id=特異メソッド-1>特異メソッド</h3><p>Stringに属したオブジェクトが全て大文字化かどうかをbooleanで返すメソッドをつくりたいが、特定の文字列にしかこのメソッドをもたせたくない、という場合。Refinementsを使って、特定のコードの前にusingを挿入するという方法もありますが、別の方法もあります。それが特異メソッドです。
同じクラスのオブジェクトでも、ある特定のオブジェクトにだけメソッドを追加したい、という場合に特異メソッドを使うことができます。</p><pre class="code lang-ruby" data-lang=ruby data-unlink> str = "string"

def str.title?
  self.upcase == self
end

p str.title? # =&gt; false
p str.methods.grep(/title?/) # =&gt; [:title?]
p str.singleton_methods # =&gt; [:title?]
 </pre><p>今までクラスに定義していたクラスメソッド</p><pre class="code lang-ruby" data-lang=ruby data-unlink> Class Hoge
  def self.a_method
  end
end
 </pre><p>これはクラスもオブジェクトであるという点からみれば</p><pre class="code lang-ruby" data-lang=ruby data-unlink> Hoge = Class.new
def Hoge.a_method
end
 </pre><p>という形とやっていることは同じです。つまりクラスメソッドはクラスの特異メソッドであるという事になります。</p><h3 id=クラスマクロ>クラスマクロ</h3><p>attt_*のようなメソッドをクラスマクロと呼ぶ。selfがクラスでも使えるのでクラスメソッドということですね。</p><h2 id=特異クラス>特異クラス</h2><p>特異メソッドがどこに定義されているのか？という問の答えが特異クラスです。</p><pre class="code lang-ruby" data-lang=ruby data-unlink> obj = Object.new
p obj # =&gt; #&lt;Object:0x00007f9fa893a068&gt;
p obj.singleton_class # =&gt; #&lt;Class:#&lt;Object0x00007f9fa893a068&gt;&gt;

singleton_class = class &lt;&lt; obj
  p self # =&gt; #&lt;Class:#&lt;Object:0x00007f9fa893a068&gt;&gt;
end
 </pre><p>この例では&lt;Class:#&lt;Object:0x00007f9fa893a068>>がobjオブジェクトの特異クラスです。
class &lt;&lt; objでも発見することができますが、singleton_classメソッドを使ったほうが楽でしょう。
オブジェクトのメソッド探索を行う際にはオブジェクトのクラスをみてそして更に親のクラスへとたどって行きますが、実は、オブジェクトのクラスのメソッドを見る前に、そのオブジェクトの特異クラスのメソッドを見にいっているのです。
クラスにもクラスはあるので、当然特異クラスがつくれます。</p><pre class="code lang-ruby" data-lang=ruby data-unlink> class C
  class &lt;&lt; self
    def a_class_method
      'C.a_class_method()'
    end
  end
end
 </pre><p>これは要は</p><pre class="code lang-ruby" data-lang=ruby data-unlink> class C
  def self.a_class_method
    'C.a_class_method()'
  end
end
 </pre><p>と同じで、クラスメソッドはそもそもそのクラスの特異クラスに定義されています。</p><pre class="code lang-ruby" data-lang=ruby data-unlink> p C.singleton_class.superclass # =&gt; #&lt;Class:Object&gt;
p C.superclass # =&gt; Object
 </pre><p>このようにクラスの特異クラスの<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%B9%A1%BC%A5%D1%A1%BC%A5%AF%A5%E9%A5%B9>スーパークラス</a>はクラスの<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%B9%A1%BC%A5%D1%A1%BC%A5%AF%A5%E9%A5%B9>スーパークラス</a>の特異クラスになります。</p><h3 id=大統一理論><a class=keyword href=http://d.hatena.ne.jp/keyword/%C2%E7%C5%FD%B0%EC%CD%FD%CF%C0>大統一理論</a></h3><p><a class=keyword href=http://d.hatena.ne.jp/keyword/Ruby>Ruby</a>のオブジェクトのルールとして７つのルールが示されています。</p><blockquote><ol><li>オブジェクトは一種類しかない。それが通常のオブジェクトかモジュールになる。</li><li>モジュールは一種類しかない。それが通常のモジュール、クラス、特異クラスのいずれかになる。</li><li><p>メソッドは一種類しかない。メソッドはモジュール（大半はクラス）に住んでいる。
一種類しかないということは複数から同時に継承しないということです。下記の５にありますが、必ず親から子への一直線以外に継承はしていません。</p></li><li><p>全てのオブジェクトは（クラスも含めて）「本物のクラス」を持っている。それが通常のクラスか特異クラスである。
<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%E1%A5%BF%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0>メタプログラミング</a><a class=keyword href=http://d.hatena.ne.jp/keyword/Ruby>Ruby</a>でのいわゆる「右へ」の移動で、本物のクラス、つまり特異クラスをもっているということですね。ほとんどのオブジェクトは特異クラスをもっています。true, false, <a class=keyword href=http://d.hatena.ne.jp/keyword/nil>nil</a>は持っていません。（NilClass等はもっていますが。）</p></li><li><p>すべてのクラスは（BasicObjectを除いて）一つの祖先（<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%B9%A1%BC%A5%D1%A1%BC%A5%AF%A5%E9%A5%B9>スーパークラス</a>かモジュール）を持っている。つまりあらゆるクラスがBasicObjectに向かって1本の継承チェーンをもっている。
これと1,2,3のルールのおかげでメソッド探索はわかりやすいものになっていると思います。継承チェーンは二股に別れたりはしていません。</p></li><li><p>オブジェクトの特異クラスの<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%B9%A1%BC%A5%D1%A1%BC%A5%AF%A5%E9%A5%B9>スーパークラス</a>は、オブジェクトのクラスである。クラスの特異クラスの<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%B9%A1%BC%A5%D1%A1%BC%A5%AF%A5%E9%A5%B9>スーパークラス</a>はクラスの<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%B9%A1%BC%A5%D1%A1%BC%A5%AF%A5%E9%A5%B9>スーパークラス</a>の特異クラスである</p></li><li>メソッドを呼び出すときは<a class=keyword href=http://d.hatena.ne.jp/keyword/Ruby>Ruby</a>はレシーバーの本物のクラスに向かって右へ進み、継承チェーンを「上へ」進む。
この２つからなぜ<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9>インスタンス</a>がクラスメソッドにアクセス出来ないかを説明することができます。
クラスメソッドはそのクラスの特異クラスに定義されています。
<a class=keyword href=http://d.hatena.ne.jp/keyword/Ruby>Ruby</a>のメソッド探索では一度だけしか右に行かないので、<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9>インスタンス</a>からメソッド探索をおこなった場合、メソッドの特異クラスへと一度右に行った後はその特異クラスの<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%B9%A1%BC%A5%D1%A1%BC%A5%AF%A5%E9%A5%B9>スーパークラス</a>であるobj.classが戻すクラスから上に探索していくので、その<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%B9%A1%BC%A5%D1%A1%BC%A5%AF%A5%E9%A5%B9>スーパークラス</a>の特異クラスまでは探索しません。よって<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%B9%A1%BC%A5%D1%A1%BC%A5%AF%A5%E9%A5%B9>スーパークラス</a>の特異クラスにあるメソッドは<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9>インスタンス</a>からはアクセスできないということになります。</li></ol></blockquote><h3 id=Objectextend>Object#extend</h3><p>モジュールをincudeするとモジュールの<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9>インスタンス</a>メソッドのみがincludeしたクラスで<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9>インスタンス</a>メソッドとして使えるようになりますが、
クラスの特異メソッドを開いて、その中でモジュールをincludeするとモジュールの<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9>インスタンス</a>メソッドをクラスメソッドとして定義できます。
オブジェクトの特異クラスにも同様にでき、よく使われるので、Object#extendとしてメソッドが提供されています。</p><pre class="code lang-ruby" data-lang=ruby data-unlink> module MyModule
  def my_method; p 'hello'; end
end

class MyClass
  extend MyModule
end

MyClass.my_method # =&gt; 'hello'
 </pre><h2 id=メソッドラッパー>メソッドラッパー</h2><h3 id=アラウンドエイリアス>アラウンド<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9>エイリアス</a></h3><ol><li>メソッドに<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9>エイリアス</a>をつける</li><li>メソッドを再定義する</li><li>新しいメソッドから古いメソッドを呼び出す。
こうすることで<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9>エイリアス</a>では元のメソッドの内容が参照されるため、</li></ol><pre class="code lang-ruby" data-lang=ruby data-unlink> class String
  alias_method :origin_reverse!, :reverse!

  def reverse!
    upcase!
    origin_reverse!
  end
end

p "ruby".reverse! # =&gt; "YBUR"
 </pre><p><a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9>エイリアス</a>を定義することで、メソッドの再定義を行う時に、元のメソッドを<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9>エイリアス</a>メソッドで呼び出して、ラップすることができます。
ここでは古い<code>reverse!</code>を新しい<code>reverse!</code>にラップしています。一種のモンキーパッチにも近い方法です。
新しい<code>reverse!</code>は古い<code>reverse!</code>の周囲（アラウンド）をラップしているのでこのトリックをアラウンド<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9>エイリアス</a>をと呼びます。</p><h3 id=Refinements>Refinements</h3><p>Refinementsを使ってsuperを呼び出すと元のメソッドを呼び出せます。</p><pre class="code lang-ruby" data-lang=ruby data-unlink> module StringRefinements
  refine String do
    def reverse!
      upcase!
      super
    end
  end
end

using StringRefinements
p "python".reverse! # =&gt; "NOHTYP"
 </pre><h3 id=Prependラッパー>Prependラッパー</h3><pre class="code lang-ruby" data-lang=ruby data-unlink> module ExpilcitString
  def reverse!
    upcase!
    super
  end
end

String.class_eval do
  prepend ExpilcitString
end

p "go".reverse! # =&gt; "OG"
 </pre><p>Prependは継承チェーンの下にモジュールが挿入されるのでメソッド探索の際にはprependされたモジュールにあるメソッドが先に使われる。</p><h2 id=５章のクイズ>５章のクイズ</h2><p>最初はsuperで解決しようとしたんですが、古い+に依存しているのでなかなか書けませんでした…
<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%E1%A5%BF%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0>メタプログラミング</a><a class=keyword href=http://d.hatena.ne.jp/keyword/Ruby>Ruby</a>のようにアラウンド<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9>エイリアス</a>で解決するのが良さそうです。</p><h2 id=まとめ>まとめ</h2><p>クラスメソッドがどこに定義されているのか？という問いに答えてくれる章でしたね。
<a class=keyword href=http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9>ソースコード</a>を読んでextendってなんだ？となることが多かったので、extendで特異クラスにメソッドを定義できるのは知っておきたいところ。
また特異クラスには特異クラスがあるので特異クラスの特異クラスの特異クラスとずっとつなげて行けるのでは…</p></body></div></article></main></div><footer class=footer><span class=footer_item></span>&nbsp;<div class=footer_social-icons></div><small class=footer_copyright>© 2024 .</small></footer><script src=https://qwyng.dev/js/main.min.4ee188e1744c19816e95a540b2650ed9f033ea0371e74eac8e717355cfca8741.js integrity="sha256-TuGI4XRMGYFulaVAsmUO2fAz6gNx506sjnFzVc/Kh0E="></script></body></html>